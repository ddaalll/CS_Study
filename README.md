# CS_Study

# 컴퓨터 구조/운영체제

## 컴퓨터 주요 구성 요소 (3가지 핵심)

- Memory(코드와 데이터를 저장하는 장치)
    - 프로그램과 프로그램 수행에 필요한 데이터를 저장
    - 내부 기억장치 (주기억장치)
        - CPU 안에 레지스터(register) 캐쉬(cache memory)
        - DRAM등 메모리 (램, RAM, DDR4)
    - 외부 기억장치 (보조기억장치)
        - SSD, HDD

- IO Devices(입출력 장치)
    - 입력 장치: 마우스 키보드, 터치패드 등
    - 출력 장치: 모니터, 프린터, 스피커 등

- Bus(버스)
    - CPU, Memory, IO Devices를 연결해주는 장치
    - 개별적인 IO Devices들을 연결해주고 데이터를 송수신해주는 장치

비트(bit)

A bit : 0 or 1

논리연산

AND Gate (직렬연결)                  OR Gate(병렬연결)

| A | B | output |               | A | B | output |
| 0 | 0 | 0 |                    | 0 | 0 | 0 |
| 0 | 1 | 0 |                    | 0 | 1 | 1 |
| 1 | 0 | 0 |                    | 1 | 0 | 1 |
| 1 | 1 | 1 |                    | 1 | 1 | 1 |



이진수의 덧셈(가산기)

- 반가산기 (half adder)
- 반가산기: 두 bit를 덧셈하는 가산기를 의미
    - 전가산기: 두 bit 외, carry까지 계산할 수 있는 가산기를 의미
- 각각 하나의 bit인 A와 B를 더해서, 합 S와 자리 올림(Carry) C를 출력하는 조합논리 회로

논리 연산

NOT Gate, 그리고 다른 Gate와의 조합

논리 연산

NAND 와  NOR Gate (AND 와  OR의 결과값과 반대면 됨)


논리 연산

- 부울 대수식
    


논리연산

- AB + CD = Y 와 (A + B)(C + D) = Y


이진수의 덧셈 1 (가산기)

간단한 논리연산을 가지고 계산기를 만들 수 있다.

- 0 + 0 = 0
- 0 + 1 = 1
- 1 + 0 = 1
- 1 + 1 = 0, 하지만 다음 자릿수를 1 더해야 함 (carry 라고 함)

이진수의 덧셈 - XOR게이트 (가산기)

- OR와 NAND 게이트에 AND 게이트를 연결할 경우, XOR 게이트와 동일한 값을 만들 수 있음

- 반가산기 (half adder)
- 반가산기 : 두 bit를 덧셈하는 가산기를 의미
- 전가산기 : 두 bit외, carry 까지 계산 할 수 있는 가산기를 의미
- 각각 하나의 bit인 A와B를 더해서, 합 S와 자리올림(Carry) C를 출력하는 조합 논리 회로

- 전가산기 (full adder)
- 반가산기를 조합해서 전가산기 만들기
- 전가산기는 A bit, B bit, carry bit 값을 입력으로 받아서, sum과 carry값을 출력해줌

- 8비트 전가산기 - 8개를 연결해서 조합하면 - 조금더 추상화 해서 표기하면

- 16비트 전가산기 (2의 16승 = 65536 까지 덧셈 가능)

클럭 - 최근CPU : 2.5 GHz

1GHz = 1,000MHz = 1,000,000,000Hz

Oscillator

클럭을 만들 수 있다

- Cycle : a interval
- 주기 : 한 사이클에 필요한 시간
- frequency(단위-hertz): 주기 / 1 (cycle/sec)

### 플립플롭 = 메모리

NOR 게이트 조합

- flip-flop (플립플롭): 데이터를 저장하는 조합논리회로

### RS플립플롭

- R-S(Reset-Set) flip-flop
    - Q는 output
    - 단, S 와 R이 1인 상태는 피하도록 설계
        
        플립플롭(Level-triggered flip-flop)
        
        ### 플립플롭(D-type flip-flop)
        
        - R/S(두 input)를 Data(하나의 input) 으로 바꿈
            - R/S 둘다 1일 경우는 피하도록 헐계
            - R/S 둘다 0일 경우도 Q값에 영향을 안주므로 삭제

        ### Level-triggered D-type flip-flop(플립플롭)
        
        - D는 Data
        - Level-triggered는 Hold That Bit이 1 일 때만 Data 값을 저장한다는 의미
        - RS 플립플롭에서 R/S 둘다 1, 0 일 경우를 피하도록 설계한 조합 논리회
        

### 1 bit latch

- Level-triggerd D-type flip-flop
    - Hold That Bit 를 Write로 표기
    - Data In이 데이터를 넣을 때, Write 도 1이 되어야 함
    - 1 bit를 일시적으로 저장할 수 있는 메모리

### 8 bit latch

- Write가 1 일때 8bit Data Inputs이 8 bit Data Output에 저장됨
- Write가 0이면 8bit Data Outputs 값이 유지 됨

### 8-to-1 selector

- 8 bit 데이터에서 특정 bit 값만 출력하기

### 3-to-8 decoder

- 8개의 출력 중, V 스위치로 단 하나으 ㅣ출력 이외에는 0
- Write가 1, V 스위치로 특정 출력 선정, Data In의 값이 특정 latch에 쓰여짐

온전한 8 bit latch 회로

- 3-to-8 decoder 와 8-to-1 selector 로 구성 (이게 바로 주소, Address)
- S0, S1, S2 가 decoder 와 selector에 동일하게 적용 (데이터를 읽고 쓸 수 있는 Address)
- Write가 1이면, Address에 Data In 값이 씌여짐
- Data Out은 항상 Address에 해당하는 값을 출력

RAM (Random Access Memory)

- 온전한 8 bit latch 회로가 바로 RAM
    - 3-to-8 decoder 와 8-to-1 selector로 구성
    - 3 Address 가 있으면 8 개중 하나의 비트를 선택해서 쓰거나, 읽을 수 있다

- 8 X 1 RAM: 8개 비트중 1개의 특정 비트를 쓰고, 읽을 수 있는 메모리
    - 특징 1 - Memory: 데이터를 저장할 수 있음
    - 특징 2 - Read/Write: 특정 공간에 새로운 데이터 저장, 읽기 가능
    - 특징 3 - Random Access: Address 지정을 통해 특정 공간 값 접근 가능
        - 반면 어떤 메모리는 순차접근만 가능
            - 예 100주소를 읽기 위해 99를 읽어야 함

### RAM array

- 8 X 1 RAM 을 두개 엮음
    - Data In은 각 8 X 1 RAM에 별도로 입력이 들억마
    - Address와 Write는 두 8 X 1 RAM에 동일하게 입력이 들어감

### 8 X 2 RAM array

- 8개의 데이터를 저장하고 읽는데 각 데이터는 2bits 이다.


### 16 X 1 RAM array

- 8 X 2 RAM array 구조에, Select 와 1-to-2 Decoder/2-to-1 Selector 추가
- 즉, Select 는 4번째 Address 역할을 함
- 16개의 데이터를 저장하고 읽는데, 각 데이터는 1bit 가 됨
    

    ### M*N RAM array
    
    - 많은 데이터를 저장하는 RAM array
        - 8 X 1 RAM 을 여러개 연결하고, 여러 개의 Select로  Decoder/Selector를 구성하면 많은 데이터를 읽고, 저장할 수 있음
        - 예 :
            - Address 10개: 2의 10승 → 1024
            - DI 8개: 1byte(8 bits)
            - 1024 X 8 bits = 8196 bits를 다루는 RAM array


### 64K RAM

- Address 수 / Data In/Out 수 로 RAM array 만들기
    - 65,536(2의  16승) X 8 bits
    - 2의 16승 —> 16은 2 bytes, byte 단위가 편하기 때문


### Accumulator(가산기)

- Clear 입력 추가 (data 삭제)
    - Clear 가 1이면, Q output은 0이 됨
    - Flip-flop 값을 삭제 할 수 있다.
    - Data 에 어떤 입력이 오든간에 Clear 입력으로 output 삭제
- 8-bit Adder 와 8-Bit Latch 로 구성
- 8-bit Latch 에서
    - Clear 스위치는 Clear 입력에 들어감
    - Add 스위치는 Clock 입력에 들어감
        - 8-bit Adder에서 덧셈이 계산되고, 이 값이 8-bit latch 에 들어가려면, Add 스위치가 눌러졌을 때, 8-bit latch 에 저장 됨
        - 축적 되는 느낌, clear 버튼 을 눌러 초기화를 해주 어야 함
                    

레지스터는 CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치


### 메모리 안에서 최대한 처리를 할 수 있도록 프로그래밍 (속도 때문)

### Assembly 언어 예

### Program Counter (PC)

- 16-Bit Counter: 1씩 증가하는 조합논리회로

### Programming

- “Data” & “Code”
    - 각 주소에 대응해서 Load, Add, Store를 의미하는 갑승ㄹ 만들어야 함
    - RAM을 분리하여 명령을 의미하는 값을 순차적으로 넣어주면, 코드를 실행할수 있음
    - h 는 Hex(16진수)를 의미함
    - 명령 숫자: Instruction Code, Operation Code, 또는 Opcode 라고 함

Load 와 Store 명령

- Load: 2-to-1 Selector로 Data를 Add 하지 않고 바로 8-bit Latch에 넣음
- Store: 8-bit latch의 Output을 바로 64Kx8 RAM에 저장 (Write 스위치를 1로 만듬)

### Digital Computer

- CPU, Memory, PC, Input(Switches), Output(출력전구)
    - Digital Computer: 구분된 숫자를 기반으로 동작하는 컴퓨터
    - Memory: 64KB RAM

## Software

### Instruction Set 과 코드

- Software: Code + Data
    - Software Engineer: Code 를 작성하는 사람
    - Machine language: CPU는 Instruction code를 만들어 놓고, 제공함
    - 컴파일: 프로그래밍 언어로 작성된 프로그램은 컴파일러를 통해 CPU가 제공하는 Instruction code를 기반으로 변환됨
- 컴파일러 : 고급 언어로 작성된 코드를 한번에 기계어로 변환하는 프로그램 (대표 언어: C언어, JAVA)
    - 특정 프로그램을 통해 기계어로 변환된 파일을 만듦

- 인터프리터 : 고급 언어로 작성된 코드를 한줄씨 기계어로 변환하는 프로그램 (대표언어 : Python, PHP, Ruby 등)
    - 컴파일은 필요없고, 실시간으로 읽어 표현

- 주소도 약자로 만들기
- BEGIN : LOD A, [1005h] - 코드 재작성시 주소 변경이 되므로 이름붙이기
    - 고급 언어에서는 함수와 변수에 이름을 붙이는 작업이 됨
    

### 다시 이해하는 폰노이만 구조(현 컴퓨터 구조)

- Controller Unit : Program Counter
- ALU: 가산기 + 논리연산 + Register

### 컴퓨터의 CPU 기본 구조

- CPU에 레지스터 라는 저장곤간이 있음 - 빠른 실행
    - PC (Program Counter): 다음 실행할 명령어 주소를 가리키는 레지스터
    - IR (Instruction Register): 가장 최근에 인출한 명령어 보관 레지스터
    - 누산기(ACC, Accumulator): 데이터 일시 보관 레지스터
    - MAR(Memory Address Register): CPU가 메모리 참조위해 보관하는 데이터 주소를 가진 레지스터
    - MBR(Memory Buffer Register): CPU가 메모리로부터 읽거나, 저장할 데이터 자체를 보관하는 레지스터

### 현 컴퓨터의 CPU 기본 실행 구조

1. Instruction Fetch : 실행할 명령어를 메모리에서 읽어 CPU로 가져옴
    1. PC가 가리키는 주소를 MAR 에 보냄
    2. MAR에 적힌 주소를 메모리에서 읽어서 MBR에 보냄
    3. MBR에 있는 명령어를 IR에 저장
    4. 다음 명령어를 가리키도록 PC는 주소값 증가
2. Instruction Decode : 인출한 명령어에 포함된 데이터 가져오고 명령어 해독
3. Instruction Execution : 명령어 실행
    1. MBR의 데이터와 ACC (Accumulator)의 데이터로 연산 후, ACC (Accumulator)에 저장
4. Write Back : 실행 결과를 저장

### CPU 성능을 높이는 기법 - 파이프라인

- 파이프라인 : 하나의 작업에 필요한 일을 세부적으로 나누어서 동시에 다른 세부작업을 실행하는 기법 (세부적으로 나눌 수록 처리가 빨라짐)

- Fetch Stage (Instruction Fetch/Decode)
- Execution Stage (Instruction Excution)

- 명령어 인출(IF : Instruction Fetch)
- 명령어 해독(ID : Instruction Decode): 인출된 명령어 해석
- 오퍼랜드 인출(OF : Operand Fetch) : 메모리에서 데이터 인출
- 명령어 실행(EX : Excute)
- 실행 결과 저장 (SR: Store)

파이프라인을 타고 실행이 되다가 ,마지막에 보안에 이슈가 있으면 전체 취소, 그때까지 줄을 서서 실행되고 있는 나머지 코드도 다 실행 취소됨, 따라서 그만큼 CPU사용을 낭비

### ARM vs Intel

### CPU 명령어를 정의하는 전략 -  RISC vs CISC

- CISC(Complex Instruction Set Computer)
    - 하나의 명령어 실행으로 가능한 한 많은 작업을 수행(복합 령령어)
    - 복합 명령어 수행을 위해 CPU 로직 회로 복잡도 증가
        - 하나의 명령어 실행 시간 증가
- RISC(Reduced Instruction Set Computer)
    - 간단한 명령어를 조합해서 실행하면 더 효율적이지 않을까?

CISC의 특성

- 명령어의 포맷이나 길이에 관한 규칙이 없음
- 하나 이상의 사이클로 명령어(세부 작업) 실행
- 전체 명령이 얼마나 걸릴지 시간 예측이 어려움
- 인자(arguement) 가 많아 짐

RISC의 특성

- 명령어의 포맷과 길이 고정
- 하나의 사이클로 명령어(세부 작업) 실행
- 전체 명령 시간 예측이 가능

**CISC/RISC CPU**

- 대표적인 CISC CPU : 인텔 CPU
- 대표적인 RISC CPU : ARM
    - 스마트폰, 임베디드, IoT 기기

### 메모리

- 메모리가 비싸서, 성능을 높이기 위한 전략
    - 비산 메모리는 CPU바로 옆에, 단 작게
    - 느린 메모리는 먼 곳에, 단 크게
    

- Register : CPU 안에서 데이터 보관
- SRAM: L1, L2, L3 캐쉬
    - 최대한 가장 많이 사용하는 메모리의 데이터를 넣어 놓아서, 메모리까지 접근하지 않고 CPU가 가져다 쓸 수 있게 함
- DRAM: 메모리
- SSD/HDD(하드디스크): 컴퓨터를 꺼도 데이터 보전

### DMA(Direct Memory Access)

- CPU가 캐쉬까지는 데이터를 가져오는데 관여하지만 (Instruction Fetch)
- 메모리, SSD에서 데이터를 가져오는데 까지 관여하면 CPU 활용도가 낮아진다
    - DMA라고 만들어서 메모리, SSD에서 데이터를 관리하면 CPU는 이 시간을 명령실행에 더 쓸수 있다.

### IO Device

## 운영체제

운영체제란: OS(Operation System)

주요 운영체제: 윈도우, UNIX 계열 OS (리눅스), Mac OS

 

OS는 더 정확히는 커널(kernal)을 의미함

### 운영체제는 사용자 인터페이스 제공: 쉘

- 쉘(Shell)
    - 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램
    - 쉘은 터미널 환경(CLI)과, GUI 환경 두 종류로 분류
    - 유명한 쉘: 리눅스 bash

### 운영체제는 응용 프로그램 인터페이스 제공: 시스템 콜

- 시스템 콜(System Call)
    - 시스템 콜 또는 시스템 호출 인터페이스
    - 운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공

### 프로그래밍 언어별 해당 운영체제에 맞는 API 구현

- API(Application Programming Interface)
    - 모호한 용어이지만, 간단히 함수 또는 라이브러리라고 이해하면 됨
- API 내부에는 필요시 해당 운영체제의 시스템콜을 호출하는 형태로 만들어짐

함수든 변수든 결국 주소가 있고, 해당 주소에서 코드를 실행하는 형태

### 운영체제를 만든다면?

1. 운영체제를 개발한다. (kernel)
2. 시스템콜을 개발
3. 시스템콜 기반, 프로그래밍 언어별 라이브러리 개발(API)
4. 지원되는 프로그래밍 언어로 Shell 프로그램 개발
5. 지원되는 프로그래밍 언어로 응용 프로그램 개발

### 사용자 모드와 커널 모드

- 함부로 응용 프로그램이 전체 컴퓨터 시스템을 헤치지 못함

응용프로그램에서 시스템 콜을 통해 커널에 요청 → 커널에서 결과만 응용 프로그램으로 전달 

- 응용프로그램 ↔ API ↔ 시스템 호출 인터페이스 ↔ 커널

### CPU Protection Ring

- 사용자 모드 (user mode): 응용 프로그램이 사용
- 커널 모드 (kernal mode): OS가 사용

### 시스템 콜은 커널 모드로 실행

- 커널 모드에서만 실행 가능한 기능들이 있음
- 커널 모드로 실행하려면, 반드시 시스템 콜을 사용해야 함(거쳐야 함)
- 시스템 콜은 운영체제 제공

### 정리

- 운영체제는 **시스템 콜** 제공
- 프로그래밍 언어별 운영체제 지원을 위해, 운영체제 별 **API** 제공
- 응용 프로그램 개발시 운영체제 기능이 필요한 경우, 해당 **API**를 사용해서 프로그램 작성
- 응용 프로그램 실행시, 해당 **API**를 호출 하면, 시스템 콜 호출, **커널 모드로 변경 후,** OS 내부에서 해당 명령이 실행되고, 응용 프로그램에 결과 리턴

### 운영체제 역할1: 시스템 자원(System Resource)관리자

- 시스템 자원(System Resource) = 컴퓨터 하드웨어
    - CPU (중앙처리장치), Memory (DRAM, RAM)
    - I/O Devices (입출력장치)
        - Monitor, Mouse, Keyboard, Network
    - 저장매체 : SSD, HDD (하드디스크)
    
1. CPU: 각 프로그램이 얼마나 CPU를 사용할지를 결정할 수는 없다.
2. Memory 각 프로그램이 어느 주소에 저장되어야 하는지, 어느 정도의 메모리 공간을 확보해줘야 하는지를 결정할 수는 없다.
3. 저장매체(HDD,SSD) : 어떻게, 어디에 저장할지는 결정할 수 없다.
4. 키보드/마우스: 스스로 표시할 수는 없음.

### 응용 프로그램이란?

- 프로그램 = 소프트웨어
- 소프트웨어 = 운영체제, 응용 프로그램(엑셀, 파워포인트, 등)
- 응용 프로그램 = Appication(일반 PC에서의 프로그램) = App (스마트폰에서 응용 프로그램)

### 운영체제와 응용 프로그램간의 관계

- 운영체제는 응용 프로그램을 관리
    - 응용 프로그램을 실행시킨다
    - 응용 프로그램간의 권한을 관리해준다
        - 관리자 권한으로 실행
    - 응용 프로그램을 사용하는 사용자도 관리
        - 로그인

1. 응용 프로그램을 관리한다
2. 시스템 자원(System Resource)를 관리한다
3. 사용자와 컴퓨터간의 커뮤니케이션을 지원

운영체제의 목표: 사용자가 사용하는 응용 프로그램이 효율적으로, 적절하게 동작하도록 지원

운영체제는 응용 프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고, 지원하는 소프트웨어

정리

1. 운영체제의 역할: 시스템 자원, 응용 프로그램 관리,  효율전 분배 
2. 응용 프로그램이란? - 소프트웨어 (운영체제, 응용 프로그램)

### 프로세스 (process) 란?

- 실행중인 프로그램은 프로세스라고 함
    - 프로세스 : 메모리에 올려져서, 실행중인 프로그램
    - 코드 이미지(바이너리): 실행 파일
- 응용 프로그램 ≠ 프로세스
    - 응용 프로그램은 여러 프로세스로 구성 가능

프로세스라는 용어는 작업, task, job 이라는 용어와 혼용

### 현업, IT기술과 컴퓨터 공학의 이해

- 엑셀 프로그램과 엑셀 프로세스
    - escel.exe(코드 이미지, 바이너리) 와 엑셀 프로세스
- 휴대폰에서 앱이 실행되어 있을 때가 앱이 프로세스로 실행 될 때임

### 배치 처리 시스템

- 여러 프로그램을 순차적으로 실행시킬수 있도록 해라
    - 어떤 프로그램은 실행이 너무 시간이 많이 걸려서, 다른 프로그램이 실행하는데 시간을 많이 기다려야 한다

### 시분할 시스템

- 시분할 시스템 다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템
    - 여러 사용자가 동시에 하나의 컴퓨터를 쓰려면 (다중 사용자 지원)

### 멀티태스킹

- 멀티 태스킹: 단일 CPU에서, 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템
    - MP3 음악을 들으며, 문서 작성을 한다
- 10 ~ 20 ms 단위로도 실행 응용 프로그램이 바뀜

### 멀티 프로그래밍

- 최대한 CPU를 많이 활용하도록 하는 시스템
    - 응용 프로그램은 CPU외 다양한 하드웨어 사용 (파일 읽기)

### 메모리 계층 - 컴퓨터 구조 이해

### 멀티 프로그래밍과 Wait

- 멀티 프로그래밍 : CPU 활용도를 극대화 하는 스케쥴링 알고리즘
- Wait : 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정

### 멀티 태스킹과 멀티 프로세싱

- 멀티 태스킹과 멀티 프로세싱
    
- 멀티 태스킹 : 단일 CPU
- 멀티 프로세싱 : 여러 CPU에 하나의 프로그램을 병렬로 실행해서 실행속도를 극대화시키는 시스템

- 프로그램 성능을 높이는 방법
    - 가능한 메모리상에서 실행하도록 해야 함
    - 예 : Redis / Scala
    

### 정리

- 시분할 시스템 : 다중 사용자 지원, 컴퓨터 응답시간을 최소화하는 시스템
- 멀티 태스킹 : 단일 CPU에서 여러 응용 프로그램을 동시에 실행하는 것처럼 보이게 하는 시스템
- 멀티 프로그래밍 : 최대한 CPU를 일정 시간당 많이 활용하는 시스템
- 멀티 프로세싱 : 여러 CPU에서 하나의 응용 프로그램을 병렬로 실행해서, 실행속도를 높이는 기법

### 단골 CS지식 문제

1. 프로세스 구조에 대해 가능한 상세하게 설명해주세요
2. 컨텍스트 스위칭에 대해 가능한 상세하게 설명해 주세요
3. 프로세스간에는 어떻게 통신하는지 가능한 상세하게 설명해주세요

### 스케쥴링 알고리즘

- 목표
    - 시분할 시스템 예: 프로세스 응답시간을 가능한 짧게
    - 멀티 프로그래밍 예 : CPU 활용도를 최대로 높혀서, 프로세스를 빨리실행

### FIFO스케쥴러

- 가장 간단한 스케쥴러 (배치 처리 시스템)
- FCFS (First Come First Served) 스케쥴러

### 최단 작업 우선( SJF)스케쥴러

- SJF(Shortest Job First) 스케쥴러
    - 가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행을 시키는 알고리즘
- SJF 스케쥴러도 실제로 좋은 개발자답게 작성한다면
    - 자료구조와 알고리즘에 익숙한 상태라면, 좋은 개발자는 분명히 최소한 우선순위 큐와 힙 자료주고 사용을 고려할 것임 (시간복잡도가 O(nlogn)임)
    - 스케쥴러는 운영체제 핵심기능으로 빈번하게 호출되므로, 스케쥴러 알고리즘은 운영체제 성능에 큰 영향을 미침
    
- RealTime OS(RTOS) : 응용 프로그램 실시간 성능 보장을 목표로 하는 OS
    - 정확하게 프로그램 시작, 완료 시간을 보장
    - Hardware RTOS, Software RTOS
- General Purpose OS (GPOS):
    - 프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS, 예 : Windows, Linux 등

### 우선순위 기반 스케쥴러

- Priority-Based 스케쥴러
    - 정적 우선순위
        - 프로세스마다 우선순위를 미리 지정
    - 동적 우선순위
        - 스케쥴러가 상황에 따라 우선순위를 동적으로 변경

### Round Robin 스케쥴러

### 정리

- 다양한 기본 스케쥴링 알고리즘
    - FIFO (FCFS)스케쥴링 알고리즘 (배치 처리 시스템)
    - 최단 작업 우선(SJF) 스케쥴링 알고리즘
    - 우선순위 기반 스케쥴링 알고리즘
        - 정적 우선순위, 동적 우선순위
    - Round Robin 스케쥴링 알고르짐
        - 시분할 시스템
    - 프로세스 상태 기반 스케쥴링 알고리즘
        - 멀티 프로그래밍
    
- 현업 프로그램은 성능에 민감함
    - 대용량 서비스
- 성능을 위해 꼭 체크해야 하는 포인트
    - 당신의 프로그램이 IO-bound냐, CPU-bound 냐
        - IO-bound : IO 관련 기능이 주로 사용하는 프로그램 // 네트워크, 파일(저장매체)
        - CPU-bound : CPU /  메모리를 주로 사용하는 프로그램 // 계산기 (CPU에서만)

### 프로세스 구조

- 프로세스 (process)는 일반적으로 어떻게 구성되어 있을까
    - text(CODE) : 코드,
    - data : 변수 / 초기화된 데이터
    - stack : 임시 데이터(함수 호출, 로컬 변수등)
    - heap : 코드에서 동적으로 만들어 지는 데이터
    
- 프로세스와 컴퓨터 구조
    - PC(Program Counter) + SP(Stack Pointer)
        - PC : 다음 실행할 코드 주소
        - SP : 스택 최상단 주소
    - 임베디드 시스템등에서 동작하는 C프로그램등은 디버깅시 PC와 SP를 캡쳐해서 확인
    
- JAVA GC 와 프로세스 힙 (동적메모리)
    - JAVA GC 가 필요한 이유
        - 불필요한 객체가 차지하는 힙 공간을 삭제하여, 힙 공간 확보가 필요하기 때문
        - 만약 힙 공간이 부족하면? 객체 생성이 불가하고, JAVA 와 같은 객체지향 프로그램은 동작하지 않게 됨
        
    

### 컨텍스트 스위칭(Context Switching)

- Context Switching, 컨텍스트 스위칭 , 또는 문백 교환
    - CPU에 실행할 프로세스를 교체하는 기술
- PC, SP만 바꿔주면 프로세스 저장상태를 기반으로 실행 가능

컨텍스트 스위칭 세부동작 

1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트 해서, 메인 메모리에 저장
2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 **PCB정보(PC, SP)를  CPU의 레지스터에 넣고,** 실행

### Process Control Block (PCB)

- PCB에 다음 프로세스 정보 저장
    - Process ID, Register (PC, SP) 등
    

### 프로세스간 커뮤니케이션 (InterProcess Commuication)

- 프로세스는 다른 프로세스의 공간을 접근할 수 없다.

### 다양한 IPC 기법

- IPC : InterProcess Communication
1. file 사용
2. Message Queue
3. Shared Memory
4. Pipe
5. Signal
6. Semaphore
7. Socket
8. …

2번 부터는 모두 커널 공간을 사용하는 것임 - 이것이 핵심

**Process 는 kernal 공간을 공유할수 있다, kernal공간에 메모리 공간을 만들고, 이를 사용해서 프로세스간 데이터를 공유할수 있다**

### 정리

- 여러 프로세스 동시 실행을 통한 성능 개선, 복잡한 프로그램을 위해 프로세스간 통신 필요
- 프로세스간 공간이 분리되어 있음
- 프로세스간 통신을 위한 특별한 기법 필요
    - IPC (InterProcess Communication)
- 대부분의 IPC 기법은 결국 커널 공간을 활용하는 것임
    - 이유 : 커널 공간은 공유하기 때문
    
Thread (쓰레드)

- Light Weight Process 라고도 함
- 프로세스
    - 프로세스 간에는 각 프로세스의 데이터 접근이 불가
- 스레드
    - 하나의 프로세스에 여러개의 스레드 생성 가능
    - 스레드들은 동시에 실행 가능
    - 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
    

멀티 프로세싱과 Thread

- 멀티 태스킹과 멀티 프로세싱

### Thread 장점

1. 사용자에 대한 응답성 향상
2. 자원 공유 효율 - IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요 없음, 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
3. 작업이 분리되어 코드가 간결, 사실 작성하기 나름

### Thread 단점

1. 스레드 중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받음
2. 스레드를 많이 생성하면, Context Switching이 많이 일어나, 성능 저하
- 예 : 리눅스 OS에서는 Thread를 Process와 같이 다룸
    - 스레드를 많이 생성하면, 모든 스레드를 스케쥴링해야 하므로, Context Switching이 빈번할 수 밖에 없음
1. 동기화 이슈로 비정상적으로 동작가능
- 동기화 코드를 적절히 추가해줘야 함

### Thread vs Process

- 프로세스는 독립적, 스레드는 프로세스의 서브셋
- 프로세스는 각각 독립적인 자원을 가짐, 스레드는 프로세스 자원 공유
- 프로세스는 자신만의 주소영역을 가짐, 스레드는 주소영역 공유
- 프로세스간에는 IPC기법으로 통신해야 함, 스레드는 필요 없음

### 동기화 (Synchronization) 이슈

- 동기화 : 작업들 사이에 실행 시기를 맞추는 것
- 여러 스레드가 동일한 자원(데이터) 접근시 동기화 이슈 발생
    - 동일 자원을 여러 스레드가 동시 수정시, 각 스레드 결과에 영향을 줌

### 동기화 이슈 해결 방안

- Mutual exclusion (상호 배제)
- 스레드는 프로세스 모든 데이터를 접근할 수 있으므로,
    - 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요
    - 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막는 것
- 임계 자원 (critical resource)
- 임계 영역 (critical section)

- 스레드는 자주 일부 기능에 한해서 사용
- 스레드 구현시 동기화 코드 까먹는 경우 있음 (코드가 복잡하므로, 어디에서 동기화 이슈가 일어날지 놓치는 경우가 있음)
    - 하지만, 비정상동작시, 이것이 동기화 이슈구나는 바로 인지하고
    - 관련 코드를 찾아서 상호배제 코드를 넣을 수 있어야 함
    

### Mutex 와 세마포어 (Semaphore)

- Critical Section(임계 구역)에 대한 접근을 막기위해 LOCKING 메커니즘이 필요
    - Mutex(binary semaphore) : 임계구역에 하나의 스레드만 들어갈 수 있음
    - Semaphore : 임계구역에 여러 스레드가 들어갈 수 있음, counter를 두어서 동시에 리소스에 접근 할 수있는 허용 가능한 스레드 수를 제어
    
- 휴대폰에서 특정 앱이 실행중 동작이 안될 때
    - 이유 중 하나가 데드락일 경우가 있음
    - 이를 디버깅하기 위해, 데드락이 무엇인지 이해가 필요함
    - 운영체제가 해당 앱이 특정 기간동안 반응이 없으면, 강제 종료 시킴

### 교착상태(deadlock)

- 무한 대기 상태: 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태
    
    //배치 처리 시스템에서는 일어나지 않는 문제 프로세스, 스레드 둘다 이와 같은 상태가 일어날 수 있음
    

### 기아상태(starvation)

- 특정 프로세스의 우선수위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
- 교착상태와 기아상태
    - 교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생
    - 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 경우를 주로 의미함

1. 가상 메모리와 페이징 시스템에 대해 구체적으로 설명해주세요
2. 요구 페이징과 페이지 폴트에 대해 구체적으로 설명해주세요
3. MMU와 TLB에 대해 구체적으로 설명해주세요

## 가상 메모리 (Virtual Memory System)

실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음

메모리를 늘리면 성능이 좋아진다?

폰노이만 구조 기반이므로, 코드는 메모리에 반드시 있어야 함

### 가상 메모리가 필요한 이유

- 하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템등)
    - 프로그램을 메모리로 로드(load)
    - 프로세스 실행
    - 프로세스 종료 (메모리 해제)
- 여러 프로세스 동시 실행 시스템
    - 메모리 용량 부족 이슈
    - 프로세스 메모리 영역간에 침범 이슈

### 가상 메모리

- 가상 메모리 : 메모리가 실제 메모리보다 많아 보이게 하는 기술
    - 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
    - 프로스세간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
- 가상메모리 기본 아이디어
    - 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다
    - virtual address(가상 주소) : 프로세스가 참조하는 주소
    - physical address(물리 주소) tlfwp apahfl wnth
- MMU(Memory Management Unit)
    - CPU에 코드 실행 시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치
- 메인 메모리에 실제 각 프로세스의 데이터가 조각으로 씌워져 있다

### 페이징 시스템

- 페이징(paging) 개념  // ’일괄적인 사이즈로 잘랐다’
    - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
    - 하드웨어 지원이 필요
        - 예) Intel x86시스템 (32bit)에서는 4KB, 2MB, 1GB 지원
    - 리눅스에서는 4KB로 paging
    - 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록 /사용

### 페이징 시스템 구조

- page 또는 page frame : 고정된 크기의 block (4KB)
- paging system
    - 가상 주소 v = (p , d)
        - p : 가상 메모리 페이지
        - d : p안에서 참조하는 위치
- 페이지 크기가 4KB 예
    - 가상 주소의 0비트에서 11비트가 변위(d)를 나타내고,
    - 12비트 이상이 페이지 번호가 될 수 있음

### 페이지 테이블 (page table)

- page table
    - 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
    - 가상주소 v = (p , d) 라면
        - p : 페이지 번호
        - d : 페이지 처음부터 얼마 떨어진 위치인지
- paging system  동작
    - 해당 프로세스에서 특정 가상 주소 엑세스를 하려면
        - 해당 프로세스의 page table 에 해당 가상 주소가 포함된 page 번호가 있는지 확인
        - page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아내고 (p’)
        - p’ + d 가 실제 물리 주소가 됨

### 페이징 시스템과 MMU(컴퓨터 구조)

- CPU는 가상 주소 접근시
    - MMU 하드웨어 장치를 통해 물리 메모리 접근
        - CPU → (Virtual address) → MMU → (Physical address) → Memory
- 프로세스 생성시, 페이지 테이블 정보 생성
    - PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
    - 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
    - CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서, 물리 주소를 가져옴

### 다중단계 페이징 시스템

MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함, 이 때문에 CPU가 노는 상황이 발생

이를 보완하기 위해 TLB(Translation Lookaside Buffer): 페이지 정보 캐쉬

### 페이징 시스템과 공유 메모리 (IPC)

- 프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)

### 요구 페이징 (Demand Paging 또는 Demanded paging)

- 프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
    - 선행 페이징(anticipatory paging 또는 prepaging)의 반대 개념 : 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
    - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장 **(페이지 교체 알고리즘 필요)**

### 페이지 폴트(page fault)

- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림

### 순환 구조


### 사용자/커널 모드와 프로세스, 인터럽트

### 인터럽트와 IDT

- 인터럽트는 미리 정의되어 각각 번호와 실행코드를 가리키는 주소가 기록되어 있음
    - 어디에? IDT(Interrupt Descriptor Table)에 기록
    - 언제? 컴퓨터 부팅시 운영체제가 기록
    - 어떤 코드? 운영체제 내부 코드

- 다시 예를 보면,
    - 항상 인터럽트 발생시, IDT를 확인
    - 시스템콜 인터럽트 명령은 0x80 번호가 미리 정의
    - 인터럽트 0x80 에 해당하는 운영체제 코드는 system_call()이라는 함수
    - 즉, IDT에는 0x80 → system_call()와 같은 정보가 기록되어 있음
    
- 페이지 폴트가 자주 일어나면?
    - 실행되기 전에, 해당 페이지를 물리 메모리에 올려야 함
        - 시간이 오래 걸림
- 페이지 폴트가 안 일어나게 하려면?
    - 향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 됨
        - 앞으로 있을 일을 예측해야함

### 페이지 교체 정책(page replacement policy)

- 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 다 차있다면?
    - 기존 페이지중 하나를 물리 메모리에서 저장 매체로 내리고(저장)
    - 새로운 페이지를 해당 물리 메모리 공간에 올린다.
    

### 페이지 스왑 알고리즘 (NUR)

- 

## 파일 시스템

- 파일 시스템 : 운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘

### 파일 시스템이 만들어진 이유 (파일)

- 사용자가 각 블록 고유 번호를 관리하기 어려움
    - 추상적(논리적) 객체 필요 : 파일
- 사용자는 파일단위로 관리
    - 각 파일에는 블록 단위로 관리

### 저장 방법

- 저장매체에 효율적으로 파일을 저장하는 방법
    - 가능한 연속적인 공간에 파일을 저장하는 것이 좋음
    - 외부 단편화, 파일 사이즈 변경 문제로 불연속 공간에 파일 저장 기능 지원 필요
        - 블록 체인 : 블록을 링크드 리스트로 연결
            - 끝에 있는 블록을 찾으려면, 맨 처음 블록부터 주소를 따라가야 함
        - 인덱스 블록 기법 : 각 블록에 대한 위치 정보를 기록해서, 한번에 끝 블록을 찾아갈 수 있도록 함
- 외부 단편화와 링크드리스트
- Windows : FAT , FAT32, NTFS
    - 블록의 위치를 FAT라는 자료 구조에 기록
- 리눅스(UNIX 계열) : ext2, ext3, ext4
    - 일종의 인덱스 블록 기법인 inode 방식 사용

- 파일 시스템과 파일 관련 함수 및 시스템 콜
    - 동일한 시스템콜을 사용해서 다양한 파일 시스템 지원 가능토록 구현
    - read / write 시스템 콜 호출시, 각 기기 및 파일 시스템에 따라 실질적인 처리를 담당하는 함수를 호출하는 방식으로 내부 구현됨 (예 : read_spec/write_spec)
    - 운영체제가 제공하는 시스템 콜을 기반으로, 각 언어에서 해당 시스템콜을 호출하도록 라이브러리등을 제공함

### inode 방식 파일 시스템

- 파일 시스템 기본 구조
    - 수퍼블록 : 파일 시스템 정보
    - 아이노드 블록 : 파일 상세 정보
    - 데이터 블록 : 실제 데이터

### inode와 파일

- 파일 inode 고유값과 자료구조에 의해 주요 정보 관리
    - ‘파일이름:inode’로 파일이름은 inode번호와 매칭
    - 파일 시스템에서는 inode를 기반으로 파일 엑세스
    - inode 기반 메타 데이터 저장

### inode 구조

- inode 기반 메타 데이터(파일 권한, 소유자 정보, 파일 사이즈, 생성시간 등 시간 관련 정보, 데이터 저장 위치등)

### 디렉토리 엔트리

- 리눅스 파일 탐색 : 예 - /home/ubuntu/link.txt
    - 각 디렉토리 엔트리(dentry)를 탐색
        - 각 엔트리는 해당 디렉토리 파일/디렉토리 정보를 가지고 있음
    - ‘/’ dentry에서 ‘home’을 찾고, ‘home’에서 ‘ubuntu’를 찾고, ‘ubuntu’에서 link.txt 파일 이름에 해당하는 inode를 얻음

### 가상 파일 시스템(Virtual File System)

- Network 등 다양한 기기도 동일한 파일 시스템 인터페이스를 통해 관리 가능
- 예 : read / write 시스템콜 사용, 각 기기별 read_spec/write_spec 코드 구현 (운영체제 내부)

- 모든 것은 파일이라는 철학을 따름
    - 모든 인터렉션은 파일을 읽고, 쓰는 것처럼 이루어져 있음
    - 마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어짐
    - **모든 자원에 대한 추상화 인터페이스로 파일 인터페이스를 활용**
    
- 실제 운영체제의 이해
    - 리눅스 운영체제
        - 리눅스 커널(운영체제) + 시스템 프로그램(쉘) + 응용 프로그램
        
    

### Virtual Machine (가상 머신)

- 하나의 하드웨어(CPU, Memory등)에 다수의 운영체제를 설치하고, 개별 컴퓨터처럼 동작하도록 하는 프로그램
- 하이퍼 바이저(또는 VMM) : 운영 체제와 응용프로그램을 물리적 하드웨어에서 분리하는 프로세스
- 하이퍼바이저 또는 버추얼 머신 모니터(VMM)라고 하는 소프트웨어가 하드웨어에서 직접 구동
    - Xen, KVM

### KVM

- AWS(아마존 클라우드 컴퓨팅 서비스)등에서 사용(Type1)

### Boot

- 컴퓨터를 켜서 동작시키는 절차
- Boot 프로그램
    - 운영체제 커널을 Storage에서 특정 주소의 물리 메모리로 복사하고 커널의 처음 실행위치로 PC를 가져다 놓는 프로그램
    

### 리눅스(LINUX)

- 최근 서버 환경은 주로 리눅스
- 프로그래밍을 할 떄에도 많이 사용 됩니다.
- 임베디드 시스템등에서도 많이 사용됨
    - 대표적인 예가 안드로이드임
    - 클라우드 컴퓨팅 (AWS), 도커등의 서버 기본 기술과도 함께 더욱 많이 사용됨
    

**마이크로 연산**

레지스터에서 또다른 레지스터로 보내거나, 안에서 동작하는 것을 마이크로 연산이라고 한다.레지스터는 플립플롭으로 구성되었다.하나의 clock 시간 동안 실행되는 기본 동작(shift, count, clear, load)
